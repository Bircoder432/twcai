//! Types for chat completions API

use serde::{Deserialize, Serialize};
use serde_json::Value;

use super::common::*;

/// Role of the message author
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    /// System message
    System,
    /// User message
    User,
    /// Assistant message
    Assistant,
    /// Tool message
    Tool,
    /// Function message (deprecated)
    Function,
    /// Developer message
    Developer,
}

/// Content item for multimodal messages
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum ContentItem {
    /// Text content
    Text(TextContent),
    /// Image URL content
    ImageUrl(ImageUrlContent),
    /// Input audio content
    InputAudio(InputAudioContent),
    /// File content
    File(FileContent),
    /// Refusal content
    Refusal(RefusalContent),
}

/// Chat message content - can be string or array of content items
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum ChatContent {
    /// Simple text content
    Text(String),
    /// Multimodal content array
    Array(Vec<ContentItem>),
}

/// Chat message
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ChatMessage {
    /// The role of the author of this message
    pub role: Role,
    /// The contents of the message
    pub content: ChatContent,
    /// The name of the author (required for function role)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The name and arguments of a function that should be called
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_call: Option<FunctionCall>,
    /// Tool call information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Value>,
    /// Tool call ID (required for tool role messages)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_call_id: Option<String>,
}

impl ChatMessage {
    /// Create a new user text message
    pub fn user(content: impl Into<String>) -> Self {
        Self {
            role: Role::User,
            content: ChatContent::Text(content.into()),
            name: None,
            function_call: None,
            tool_calls: None,
            tool_call_id: None,
        }
    }

    /// Create a new assistant text message
    pub fn assistant(content: impl Into<String>) -> Self {
        Self {
            role: Role::Assistant,
            content: ChatContent::Text(content.into()),
            name: None,
            function_call: None,
            tool_calls: None,
            tool_call_id: None,
        }
    }

    /// Create a new system text message
    pub fn system(content: impl Into<String>) -> Self {
        Self {
            role: Role::System,
            content: ChatContent::Text(content.into()),
            name: None,
            function_call: None,
            tool_calls: None,
            tool_call_id: None,
        }
    }

    /// Create a new multimodal user message
    pub fn user_multimodal(items: Vec<ContentItem>) -> Self {
        Self {
            role: Role::User,
            content: ChatContent::Array(items),
            name: None,
            function_call: None,
            tool_calls: None,
            tool_call_id: None,
        }
    }
}

/// Choice in chat completion response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ChatCompletionChoice {
    /// The index of the choice in the list of choices
    pub index: u32,
    /// A chat completion message generated by the model
    pub message: ChatMessage,
    /// The reason the model stopped generating tokens
    pub finish_reason: FinishReason,
}

/// Chat completion response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ChatCompletionResponse {
    /// A unique identifier for the chat completion
    pub id: String,
    /// The object type, which is always "chat.completion"
    pub object: String,
    /// The Unix timestamp (in seconds) of when the chat completion was created
    pub created: i64,
    /// The model used for the chat completion
    pub model: String,
    /// A list of chat completion choices
    pub choices: Vec<ChatCompletionChoice>,
    /// Usage statistics for the completion request
    pub usage: Usage,
    /// System fingerprint
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system_fingerprint: Option<String>,
}

/// Delta content for streaming responses
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct StreamDelta {
    /// The content delta for the message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
    /// The role of the message author (only in first chunk)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
}

/// Choice in streaming chat completion response
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct StreamChoice {
    /// The index of the choice in the list of choices
    pub index: u32,
    /// A chat completion delta generated by the model
    pub delta: StreamDelta,
    /// The reason the model stopped generating tokens
    pub finish_reason: Option<FinishReason>,
}

/// Streaming chat completion response chunk
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ChatCompletionStreamResponse {
    /// A unique identifier for the chat completion
    pub id: String,
    /// The object type, which is always "chat.completion.chunk"
    pub object: String,
    /// The Unix timestamp (in seconds) of when the chat completion was created
    pub created: i64,
    /// The model used for the chat completion
    pub model: String,
    /// A list of chat completion choices
    pub choices: Vec<StreamChoice>,
    /// System fingerprint
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system_fingerprint: Option<String>,
}

/// Tool choice options
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum ToolChoice {
    /// Simple option: none, auto, required
    Simple(String),
    /// Specific tool to call
    Object(Value),
}

/// Request body for chat completions
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
pub struct ChatCompletionRequest {
    /// ID of the model to use (ignored by agent, but required for compatibility)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<String>,
    /// A list of messages comprising the conversation so far
    pub messages: Vec<ChatMessage>,
    /// What sampling temperature to use, between 0 and 2
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f32>,
    /// An alternative to sampling with temperature
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_p: Option<f32>,
    /// How many chat completion choices to generate
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n: Option<u32>,
    /// Whether to stream back partial responses
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream: Option<bool>,
    /// Up to 4 sequences where the API will stop generating further tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stop: Option<StopSequence>,
    /// The maximum number of tokens to generate (deprecated)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_tokens: Option<u32>,
    /// The maximum number of tokens to generate (alternative to max_tokens)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_completion_tokens: Option<u32>,
    /// Number between -2.0 and 2.0 for presence penalty
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence_penalty: Option<f32>,
    /// Number between -2.0 and 2.0 for frequency penalty
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency_penalty: Option<f32>,
    /// Modify the likelihood of specified tokens appearing in the completion
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logit_bias: Option<Value>,
    /// A unique identifier representing your end-user
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// An object specifying the format that the model must output
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response_format: Option<ResponseFormat>,
    /// A list of tools the model may call
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<Tool>>,
    /// Controls which (if any) tool is called by the model
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_choice: Option<ToolChoice>,
    /// Options for streaming response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_options: Option<StreamOptions>,
    /// Whether to return log probabilities of the output tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logprobs: Option<bool>,
    /// An integer between 0 and 5 specifying the number of most likely tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_logprobs: Option<u32>,
}

/// Stop sequence - can be a single string or array of strings
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum StopSequence {
    /// Single stop sequence
    Single(String),
    /// Multiple stop sequences (up to 4)
    Multiple(Vec<String>),
}

/// Response format union type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum ResponseFormat {
    /// Text format
    Text(ResponseFormatText),
    /// JSON object format
    JsonObject(ResponseFormatJsonObject),
    /// JSON schema format
    JsonSchema(ResponseFormatJsonSchema),
}

/// Tool union type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum Tool {
    /// Function tool
    Function(FunctionTool),
    /// Custom tool
    Custom(CustomTool),
}

/// Request for simple agent call
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
pub struct AgentCallRequest {
    /// The message to send to the agent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Optional parent message ID for conversation context
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_message_id: Option<String>,
    /// Optional array of file IDs to attach to the message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_ids: Option<Vec<String>>,
}

/// Response from simple agent call
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct AgentCallResponse {
    /// The response message from the agent
    pub message: String,
    /// Unique ID of the message
    pub id: String,
    /// The reason why the response was finished
    pub finish_reason: Value,
}
